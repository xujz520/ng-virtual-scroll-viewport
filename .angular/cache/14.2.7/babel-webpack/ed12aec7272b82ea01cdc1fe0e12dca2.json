{"ast":null,"code":"import { ElementRef, ChangeDetectorRef, EventEmitter, NgZone } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"wrapper\"];\nconst _c1 = [\"*\"];\n/**\r\n * 虚拟滚动组件\r\n *\r\n * 尽量不要给 viewport 及其子节点设置 border、margin、padding 避免计算出错\r\n *\r\n * 为什么不使用 translateY 代替 margin-top? 因为 translateY 导致 position: sticky 出现异常\r\n */\n\nexport let VirtualScrollViewportComponent = /*#__PURE__*/(() => {\n  class VirtualScrollViewportComponent {\n    constructor(viewport, cdr, ngZone) {\n      this.viewport = viewport;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.list = [];\n      this.itemSize = null;\n      this.maxBuffer = null;\n      this.minBuffer = null;\n      this.disabled = false;\n      this.update = new EventEmitter();\n      this.vList = [];\n      this.totalHeight = null;\n      this.lastScrollTop = null;\n      this.marginTop = null;\n      this.$resizeObserver = null;\n      this.wrapper = null;\n    }\n\n    ngOnChanges() {\n      this.list = this.list || [];\n\n      if (this.disabled) {\n        this.vList = this.list;\n        return;\n      }\n\n      requestAnimationFrame(() => {\n        this.viewport.nativeElement.scrollTop = 0;\n        this.lastScrollTop = null;\n        this.updateVList();\n      });\n    }\n\n    ngAfterViewInit() {\n      this.$resizeObserver = new ResizeObserver(entries => {\n        this.ngZone.run(() => {\n          let contentRect = entries[0].contentRect;\n          if (!(contentRect.width || contentRect.height)) return;\n          this.updateVList(true);\n        });\n      });\n      this.$resizeObserver.observe(this.viewport.nativeElement);\n    }\n\n    ngOnDestroy() {\n      this.$resizeObserver.disconnect();\n    }\n\n    onScroll() {\n      if (!this.disabled) {\n        this.updateVList();\n      }\n    }\n\n    updateVList(force = false) {\n      const scrollTop = this.viewport.nativeElement.scrollTop;\n      if (!force && this.lastScrollTop === scrollTop) return;\n      const wrapperRect = this.wrapper.nativeElement.getBoundingClientRect();\n      const viewportRect = this.viewport.nativeElement.getBoundingClientRect();\n      const viewportClientHeight = this.viewport.nativeElement.clientHeight;\n      const viewportBorderWidth = (viewportRect.height - viewportClientHeight) / 2;\n      const maxBuffer = this.maxBuffer || viewportRect.height;\n      const minBuffer = this.minBuffer || viewportRect.height / 2;\n      const topBuffer = viewportRect.top - wrapperRect.top + viewportBorderWidth;\n      const bottomBuffer = wrapperRect.bottom - viewportRect.bottom + viewportBorderWidth;\n      const needUpdate = (scrollTop >= this.lastScrollTop ? bottomBuffer : topBuffer) <= minBuffer;\n      this.lastScrollTop = scrollTop;\n      if (!force && !needUpdate) return;\n      const start = Math.floor(Math.max(scrollTop - maxBuffer, 0) / this.itemSize);\n      const end = Math.ceil((scrollTop + viewportClientHeight + maxBuffer) / this.itemSize);\n      this.vList = this.list.slice(start, end);\n      this.marginTop = start * this.itemSize;\n      this.totalHeight = this.itemSize * this.list.length;\n      requestAnimationFrame(() => this.update.emit());\n      this.cdr.markForCheck();\n    }\n\n  }\n\n  VirtualScrollViewportComponent.ɵfac = function VirtualScrollViewportComponent_Factory(t) {\n    return new (t || VirtualScrollViewportComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  VirtualScrollViewportComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: VirtualScrollViewportComponent,\n    selectors: [[\"virtual-scroll-viewport\"]],\n    viewQuery: function VirtualScrollViewportComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n      }\n    },\n    hostBindings: function VirtualScrollViewportComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"scroll\", function VirtualScrollViewportComponent_scroll_HostBindingHandler() {\n          return ctx.onScroll();\n        });\n      }\n    },\n    inputs: {\n      list: \"list\",\n      itemSize: \"itemSize\",\n      maxBuffer: \"maxBuffer\",\n      minBuffer: \"minBuffer\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      update: \"update\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 5,\n    consts: [[1, \"virtual-scroll-content-wrapper\"], [\"wrapper\", \"\"], [1, \"virtual-scroll-content-spacer\"]],\n    template: function VirtualScrollViewportComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(3, \"div\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleMapInterpolate1(\"margin-top: \", ctx.marginTop, \"px;\");\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\");\n      }\n    },\n    styles: [\"*[_ngcontent-%COMP%]{box-sizing:border-box}[_nghost-%COMP%]{display:block;width:100%;height:100%;overflow:auto;position:relative;contain:content}.virtual-scroll-content-wrapper[_ngcontent-%COMP%]{min-width:100%;display:inline-block;vertical-align:middle;contain:content}.virtual-scroll-content-spacer[_ngcontent-%COMP%]{position:absolute;left:0;top:0;width:100%;z-index:-1}[_nghost-%COMP%]:hover{will-change:scroll-position}[_nghost-%COMP%]:hover   .virtual-scroll-content-wrapper[_ngcontent-%COMP%]{will-change:contents,margin}\"],\n    changeDetection: 0\n  });\n  return VirtualScrollViewportComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}